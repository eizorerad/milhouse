import type { SuspiciousPattern } from "./types";

// Pattern definitions for suspicious code
export interface PatternDefinition {
	name: string;
	regex: RegExp;
	severity: "low" | "medium" | "high" | "critical";
	description: string;
	filePatterns?: RegExp[];
}

// Built-in suspicious patterns
export const SUSPICIOUS_PATTERNS: PatternDefinition[] = [
	// Security issues
	{
		name: "hardcoded-secret",
		regex: /(?:password|secret|api[_-]?key|token)\s*[:=]\s*['"][^'"]{8,}['"]/i,
		severity: "critical",
		description: "Possible hardcoded secret or API key",
	},
	{
		name: "private-key",
		regex: /-----BEGIN (?:RSA |EC |DSA )?PRIVATE KEY-----/,
		severity: "critical",
		description: "Private key detected in code",
	},
	{
		name: "aws-credentials",
		regex: /AKIA[0-9A-Z]{16}/,
		severity: "critical",
		description: "AWS access key ID detected",
	},

	// Code quality issues
	{
		name: "console-log",
		regex: /console\.(log|debug|info)\(/,
		severity: "low",
		description: "Console logging left in code",
		filePatterns: [/\.tsx?$/, /\.jsx?$/],
	},
	{
		name: "todo-fixme",
		regex: /(?:TODO|FIXME|HACK|XXX):/i,
		severity: "low",
		description: "TODO/FIXME comment found",
	},
	{
		name: "debugger",
		regex: /\bdebugger\b/,
		severity: "medium",
		description: "Debugger statement left in code",
		filePatterns: [/\.tsx?$/, /\.jsx?$/],
	},

	// Potential bugs
	{
		name: "empty-catch",
		regex: /catch\s*\([^)]*\)\s*\{\s*\}/,
		severity: "medium",
		description: "Empty catch block swallows errors",
	},
	{
		name: "any-type",
		regex: /:\s*any\b/,
		severity: "low",
		description: "TypeScript any type usage",
		filePatterns: [/\.tsx?$/],
	},
	{
		name: "eval-usage",
		regex: /\beval\s*\(/,
		severity: "high",
		description: "Eval usage is a security risk",
	},

	// Generated code markers
	{
		name: "generated-marker",
		regex: /@generated|auto-generated|do not edit/i,
		severity: "low",
		description: "Generated code marker found",
	},
];

// Check a line against all patterns
export function checkLineForPatterns(
	line: string,
	filePath: string,
	lineNumber: number,
): SuspiciousPattern[] {
	const matches: SuspiciousPattern[] = [];

	for (const pattern of SUSPICIOUS_PATTERNS) {
		// Skip if file pattern doesn't match
		if (pattern.filePatterns) {
			const matchesFile = pattern.filePatterns.some((fp) => fp.test(filePath));
			if (!matchesFile) continue;
		}

		if (pattern.regex.test(line)) {
			matches.push({
				pattern: pattern.name,
				file: filePath,
				line: lineNumber,
				severity: pattern.severity,
				description: pattern.description,
			});
		}
	}

	return matches;
}

// Check if file is likely generated
export function isGeneratedFile(path: string, content?: string): boolean {
	// Check path patterns
	const generatedPathPatterns = [
		/\.min\.(js|css)$/,
		/\.bundle\./,
		/dist\//,
		/build\//,
		/node_modules\//,
		/\.lock$/,
		/package-lock\.json$/,
		/yarn\.lock$/,
		/pnpm-lock\.yaml$/,
		/\.d\.ts$/,
	];

	if (generatedPathPatterns.some((p) => p.test(path))) {
		return true;
	}

	// Check content markers
	if (content) {
		const generatedMarkers = [
			"@generated",
			"auto-generated",
			"DO NOT EDIT",
			"This file is automatically generated",
		];

		const firstLines = content.split("\n").slice(0, 10).join("\n");
		return generatedMarkers.some((m) => firstLines.includes(m));
	}

	return false;
}
