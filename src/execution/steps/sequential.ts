/**
 * Milhouse Sequential Step Execution
 *
 * Provides sequential task execution for the Milhouse pipeline.
 * Tasks are executed one at a time in order, with optional branching
 * and PR creation.
 *
 * Features:
 * - Sequential task execution
 * - Branch per task support
 * - Milhouse-branded PR creation
 * - Event emission for lifecycle
 * - Progress tracking with spinners
 *
 * @module execution/steps/sequential
 * @since 1.0.0
 */

import { logTaskProgress } from "../../services/config/index.ts";
import type { AIResult } from "../../engines/types.ts";
import { bus } from "../../events/index.ts";
import { createTaskBranch, returnToBaseBranch } from "../../vcs/services/branch-service.ts";
import { createPullRequest } from "../../vcs/services/pr-service.ts";
import type { LegacyTask as Task } from "../../tasks/index.ts";
import { logDebug, logError, logInfo, logSuccess } from "../../ui/logger.ts";
import { notifyTaskComplete, notifyTaskFailed } from "../../ui/notify.ts";
import { ProgressSpinner } from "../../ui/spinners.ts";
import { buildMilhousePrompt, type ParallelPromptOptions } from "../runtime/prompt.ts";
import { createBrowserConfig, legacyFlagToBrowserMode } from "../runtime/browser.ts";
import { executeWithRetry, isRetryableError } from "../runtime/retry.ts";
import { DEFAULT_RETRY_CONFIG, type MilhouseRetryConfig } from "../runtime/types.ts";
import type {
	MilhouseStepBatchResult,
	MilhouseStepHooks,
	MilhouseStepOptions,
	MilhouseStepResult,
} from "./types.ts";

import {
	addStepResultToBatch,
	createEmptyBatchResult,
	createEmptyStepResult,
	createMilhousePRBody,
} from "./types.ts";

// ============================================================================
// Constants
// ============================================================================

/**
 * Milhouse PR body template
 */
const MILHOUSE_PR_TEMPLATE = {
	prefix: "Automated PR created by Milhouse",
	footer: "*This PR was automatically generated by the Milhouse pipeline.*",
};

// ============================================================================
// Sequential Execution Core
// ============================================================================

/**
 * Execute a single task step
 *
 * @param task - Task to execute
 * @param options - Step options
 * @param hooks - Optional lifecycle hooks
 * @returns Step result
 */
async function executeStep(
	task: Task,
	options: MilhouseStepOptions,
	hooks?: MilhouseStepHooks,
): Promise<MilhouseStepResult> {
	const {
		engine,
		workDir,
		skipTests,
		skipLint,
		dryRun,
		maxRetries,
		retryDelay,
		branchPerTask,
		baseBranch,
		createPr,
		draftPr,
		autoCommit,
		browserEnabled,
		activeSettings,
		modelOverride,
	} = options;

	const startTime = Date.now();
	const result = createEmptyStepResult(task);

	// Emit task start event
	bus.emit("task:start", {
		taskId: task.id,
		title: task.title,
	});

	hooks?.onStepStart?.(task, "initializing");

	// Create branch if needed
	let branch: string | null = null;
	if (branchPerTask && baseBranch) {
		hooks?.onStepProgress?.(task, "branching", `Creating branch for ${task.title}`);
		const branchResult = await createTaskBranch(task.title, baseBranch, workDir);
		if (branchResult.ok) {
			branch = branchResult.value.branchName;
			logDebug(`Created branch: ${branch}`);
			bus.emit("git:branch:create", { name: branch });
		} else {
			logError(`Failed to create branch: ${branchResult.error.message}`);
		}
	}

	// Build prompt using modern API
	hooks?.onStepProgress?.(task, "prompting", "Building prompt");
	const browserMode = legacyFlagToBrowserMode(browserEnabled);
	const browserConfig = createBrowserConfig(browserMode);
	const milhousePrompt = buildMilhousePrompt({
		task: task.body || task.title,
		autoCommit,
		workDir,
		browser: browserConfig,
		skipTests,
		skipLint,
	});
	const prompt = milhousePrompt.text;

	// Execute with spinner
	const spinner = new ProgressSpinner(task.title, activeSettings);
	let aiResult: AIResult | null = null;

	if (dryRun) {
		spinner.success("(dry run) Skipped");
		result.status = "skipped";
		result.success = true;
		result.durationMs = Date.now() - startTime;
		return result;
	}

	try {
		hooks?.onStepProgress?.(task, "executing", "Working");

		// Build retry config using modern API
		const retryConfig: MilhouseRetryConfig = {
			...DEFAULT_RETRY_CONFIG,
			maxRetries,
			baseDelayMs: retryDelay,
			retryOnAnyFailure: options.retryOnAnyFailure,
		};

		const retryResult = await executeWithRetry(
			async () => {
				spinner.updateStep("Working");

				// Emit engine start event
				bus.emit("engine:start", {
					engine: engine.name,
					taskId: task.id,
				});

				// Use streaming if available
				const engineOptions = modelOverride ? { modelOverride } : undefined;
				if (engine.executeStreaming) {
					return await engine.executeStreaming(
						prompt,
						workDir,
						(step) => {
							const stepStr = typeof step === "string" ? step : step.category;
							spinner.updateStep(stepStr);
							hooks?.onStepProgress?.(task, "executing", stepStr);

							bus.emit("task:progress", {
								taskId: task.id,
								step: stepStr,
							});
						},
						engineOptions,
					);
				}

				const res = await engine.execute(prompt, workDir, engineOptions);

				if (!res.success && res.error && isRetryableError(res.error)) {
					throw new Error(res.error);
				}

				return res;
			},
			retryConfig,
		);

		// Handle retry result
		if (!retryResult.success || !retryResult.value) {
			throw retryResult.error ?? new Error("Execution failed after retries");
		}

		aiResult = retryResult.value;

		// Emit engine complete event
		bus.emit("engine:complete", {
			engine: engine.name,
			taskId: task.id,
			result: aiResult,
		});

		if (aiResult.success) {
			spinner.success();

			result.status = "completed";
			result.success = true;
			result.tokenUsage = {
				inputTokens: aiResult.inputTokens,
				outputTokens: aiResult.outputTokens,
				totalTokens: aiResult.inputTokens + aiResult.outputTokens,
			};
			result.aiResult = aiResult;
			result.branch = branch ?? undefined;

			// Mark task complete
			await options.taskSource.markComplete(task.id);
			logTaskProgress(task.title, "completed", workDir);

			notifyTaskComplete(task.title);

			// Emit task complete event
			bus.emit("task:complete", {
				taskId: task.id,
				duration: Date.now() - startTime,
				success: true,
			});

			// Create PR if needed
			if (createPr && branch && baseBranch) {
				hooks?.onStepProgress?.(task, "creating-pr", "Creating pull request");

				const prBody = createMilhousePRBody(task.title, aiResult.response);

				const prResult = await createPullRequest(
					branch,
					baseBranch,
					task.title,
					prBody,
					{ draft: draftPr, workDir },
				);

				if (prResult.ok) {
					logSuccess(`PR created: ${prResult.value.url}`);
					result.prUrl = prResult.value.url;
				}
			}
		} else {
			spinner.error(aiResult.error || "Unknown error");
			logTaskProgress(task.title, "failed", workDir);

			result.status = "failed";
			result.success = false;
			result.error = aiResult.error || "Unknown error";
			result.tokenUsage = {
				inputTokens: aiResult.inputTokens,
				outputTokens: aiResult.outputTokens,
				totalTokens: aiResult.inputTokens + aiResult.outputTokens,
			};

			notifyTaskFailed(task.title, aiResult.error || "Unknown error");

			// Emit task error event
			bus.emit("task:error", {
				taskId: task.id,
				error: new Error(aiResult.error || "Unknown error"),
			});

			hooks?.onStepError?.(task, new Error(aiResult.error || "Unknown error"));
		}
	} catch (error) {
		const errorMsg = error instanceof Error ? error.message : String(error);
		spinner.error(errorMsg);
		logTaskProgress(task.title, "failed", workDir);

		result.status = "failed";
		result.success = false;
		result.error = errorMsg;

		notifyTaskFailed(task.title, errorMsg);

		// Emit task error event
		bus.emit("task:error", {
			taskId: task.id,
			error: error instanceof Error ? error : new Error(errorMsg),
		});

		hooks?.onStepError?.(task, error instanceof Error ? error : new Error(errorMsg));
	}

	// Return to base branch if we created one
	if (branchPerTask && baseBranch) {
		hooks?.onStepProgress?.(task, "cleanup", "Returning to base branch");
		await returnToBaseBranch(baseBranch, workDir);
	}

	result.durationMs = Date.now() - startTime;
	hooks?.onStepComplete?.(result);

	return result;
}

// ============================================================================
// Sequential Execution Runner
// ============================================================================

/**
 * Run tasks sequentially using Milhouse step execution
 *
 * @param options - Step options
 * @param hooks - Optional lifecycle hooks
 * @returns Batch result
 */
export async function runSequentialSteps(
	options: MilhouseStepOptions,
	hooks?: MilhouseStepHooks,
): Promise<MilhouseStepBatchResult> {
	const { taskSource, maxIterations } = options;

	let batch = createEmptyBatchResult();
	let iteration = 0;

	logInfo("Milhouse: Starting sequential execution");

	while (true) {
		// Check iteration limit
		if (maxIterations > 0 && iteration >= maxIterations) {
			logInfo(`Reached max iterations (${maxIterations})`);
			break;
		}

		// Get next task
		const task = await taskSource.getNextTask();
		if (!task) {
			logSuccess("Milhouse: All tasks completed!");
			break;
		}

		iteration++;
		const remaining = await taskSource.countRemaining();
		logInfo(`Task ${iteration}: ${task.title} (${remaining} remaining)`);

		// Execute step
		const stepResult = await executeStep(task, options, hooks);
		batch = addStepResultToBatch(batch, stepResult);
	}

	return batch;
}

// ============================================================================
// Backward Compatibility
// ============================================================================

/**
 * Run tasks sequentially (legacy interface)
 *
 * @deprecated Use runSequentialSteps() instead
 */
export async function runSequential(options: MilhouseStepOptions): Promise<MilhouseStepBatchResult> {
	return await runSequentialSteps(options);
}
